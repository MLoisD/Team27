{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { debounce, capitalize } from '@mui/material/utils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nexport const rowsMetaStateInitializer = state => _extends({}, state, {\n  rowsMeta: {\n    currentPageTotalHeight: 0,\n    positions: []\n  }\n});\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  const paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const hydrateRowsMeta = React.useCallback(() => {\n    var _pinnedRows$top, _pinnedRows$bottom;\n    hasRowWithAutoHeight.current = false;\n    const densityFactor = gridDensityFactorSelector(apiRef.current.state, apiRef.current.instanceId);\n    const calculateRowProcessedSizes = row => {\n      if (!rowsHeightLookup.current[row.id]) {\n        rowsHeightLookup.current[row.id] = {\n          sizes: {\n            baseCenter: rowHeightFromDensity\n          },\n          isResized: false,\n          autoHeight: false,\n          needsFirstMeasurement: true // Assume all rows will need to be measured by default\n        };\n      }\n\n      const {\n        isResized,\n        needsFirstMeasurement,\n        sizes\n      } = rowsHeightLookup.current[row.id];\n      let baseRowHeight = rowHeightFromDensity;\n      const existingBaseRowHeight = sizes.baseCenter;\n      if (isResized) {\n        // Do not recalculate resized row height and use the value from the lookup\n        baseRowHeight = existingBaseRowHeight;\n      } else if (getRowHeightProp) {\n        const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n          densityFactor\n        }));\n        if (rowHeightFromUser === 'auto') {\n          if (needsFirstMeasurement) {\n            const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n              densityFactor\n            })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n          } else {\n            baseRowHeight = existingBaseRowHeight;\n          }\n          hasRowWithAutoHeight.current = true;\n          rowsHeightLookup.current[row.id].autoHeight = true;\n        } else {\n          // Default back to base rowHeight if getRowHeight returns null or undefined.\n          baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n          rowsHeightLookup.current[row.id].autoHeight = false;\n        }\n      } else {\n        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n      }\n      const existingBaseSizes = Object.entries(sizes).reduce((acc, _ref) => {\n        let [key, size] = _ref;\n        if (/^base[A-Z]/.test(key)) {\n          acc[key] = size;\n        }\n        return acc;\n      }, {}); // We use an object to make simple to check if a height is already added or not\n\n      const initialHeights = _extends({}, existingBaseSizes, {\n        baseCenter: baseRowHeight\n      });\n      if (getRowSpacing) {\n        var _spacing$top, _spacing$bottom;\n        const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n        const spacing = getRowSpacing(_extends({}, row, {\n          isFirstVisible: indexRelativeToCurrentPage === 0,\n          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n          indexRelativeToCurrentPage\n        }));\n        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n      }\n      const processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n      rowsHeightLookup.current[row.id].sizes = processedSizes;\n      return processedSizes;\n    };\n    const positions = [];\n    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n      positions.push(acc);\n      let maximumBaseSize = 0;\n      let otherSizes = 0;\n      const processedSizes = calculateRowProcessedSizes(row);\n      Object.entries(processedSizes).forEach(_ref2 => {\n        let [size, value] = _ref2;\n        if (/^base[A-Z]/.test(size)) {\n          maximumBaseSize = value > maximumBaseSize ? value : maximumBaseSize;\n        } else {\n          otherSizes += value;\n        }\n      });\n      return acc + maximumBaseSize + otherSizes;\n    }, 0);\n    pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight,\n          positions\n        }\n      });\n    });\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows]);\n  const getRowHeight = React.useCallback(rowId => {\n    const height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.baseCenter : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n  const getRowInternalSizes = rowId => {\n    var _rowsHeightLookup$cur;\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n  const setRowHeight = React.useCallback((id, height) => {\n    rowsHeightLookup.current[id].sizes.baseCenter = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const debouncedHydrateRowsMeta = React.useMemo(() => debounce(hydrateRowsMeta), [hydrateRowsMeta]);\n  const storeMeasuredRowHeight = React.useCallback((id, height, position) => {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n    const needsHydration = rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] = height;\n    if (needsHydration) {\n      debouncedHydrateRowsMeta();\n    }\n  }, [debouncedHydrateRowsMeta]);\n  const rowHasAutoHeight = React.useCallback(id => {\n    var _rowsHeightLookup$cur2;\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  const getLastMeasuredRowIndex = React.useCallback(() => {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  const setLastMeasuredRowIndex = React.useCallback(index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []);\n  const resetRowHeights = React.useCallback(() => {\n    rowsHeightLookup.current = {};\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(() => {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  const rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight,\n    resetRowHeights\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};","map":{"version":3,"names":["_extends","React","debounce","capitalize","useGridVisibleRows","useGridApiMethod","useGridSelector","gridDensityRowHeightSelector","gridDensityFactorSelector","gridFilterStateSelector","gridPaginationSelector","gridSortingStateSelector","useGridRegisterPipeApplier","gridPinnedRowsSelector","rowsMetaStateInitializer","state","rowsMeta","currentPageTotalHeight","positions","useGridRowsMeta","apiRef","props","getRowHeight","getRowHeightProp","getRowSpacing","getEstimatedRowHeight","rowsHeightLookup","useRef","lastMeasuredRowIndex","hasRowWithAutoHeight","rowHeightFromDensity","filterState","paginationState","sortingState","currentPage","pinnedRows","hydrateRowsMeta","useCallback","_pinnedRows$top","_pinnedRows$bottom","current","densityFactor","instanceId","calculateRowProcessedSizes","row","id","sizes","baseCenter","isResized","autoHeight","needsFirstMeasurement","baseRowHeight","existingBaseRowHeight","rowHeightFromUser","estimatedRowHeight","existingBaseSizes","Object","entries","reduce","acc","_ref","key","size","test","initialHeights","_spacing$top","_spacing$bottom","indexRelativeToCurrentPage","getRowIndexRelativeToVisibleRows","spacing","isFirstVisible","isLastVisible","rows","length","spacingTop","top","spacingBottom","bottom","processedSizes","unstable_applyPipeProcessors","push","maximumBaseSize","otherSizes","forEach","_ref2","value","setState","Infinity","forceUpdate","rowId","height","getRowInternalSizes","_rowsHeightLookup$cur","setRowHeight","debouncedHydrateRowsMeta","useMemo","storeMeasuredRowHeight","position","needsHydration","rowHasAutoHeight","_rowsHeightLookup$cur2","getLastMeasuredRowIndex","setLastMeasuredRowIndex","index","resetRowHeights","useEffect","rowsMetaApi","unstable_getLastMeasuredRowIndex","unstable_setLastMeasuredRowIndex","unstable_rowHasAutoHeight","unstable_getRowHeight","unstable_getRowInternalSizes","unstable_setRowHeight","unstable_storeRowHeightMeasurement"],"sources":["/Users/mandlenkosibernard/Documents/GitHub/Team27/bookworm_admin/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowsMeta.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { debounce, capitalize } from '@mui/material/utils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nexport const rowsMetaStateInitializer = state => _extends({}, state, {\n  rowsMeta: {\n    currentPageTotalHeight: 0,\n    positions: []\n  }\n});\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  const paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const hydrateRowsMeta = React.useCallback(() => {\n    var _pinnedRows$top, _pinnedRows$bottom;\n\n    hasRowWithAutoHeight.current = false;\n    const densityFactor = gridDensityFactorSelector(apiRef.current.state, apiRef.current.instanceId);\n\n    const calculateRowProcessedSizes = row => {\n      if (!rowsHeightLookup.current[row.id]) {\n        rowsHeightLookup.current[row.id] = {\n          sizes: {\n            baseCenter: rowHeightFromDensity\n          },\n          isResized: false,\n          autoHeight: false,\n          needsFirstMeasurement: true // Assume all rows will need to be measured by default\n\n        };\n      }\n\n      const {\n        isResized,\n        needsFirstMeasurement,\n        sizes\n      } = rowsHeightLookup.current[row.id];\n      let baseRowHeight = rowHeightFromDensity;\n      const existingBaseRowHeight = sizes.baseCenter;\n\n      if (isResized) {\n        // Do not recalculate resized row height and use the value from the lookup\n        baseRowHeight = existingBaseRowHeight;\n      } else if (getRowHeightProp) {\n        const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n          densityFactor\n        }));\n\n        if (rowHeightFromUser === 'auto') {\n          if (needsFirstMeasurement) {\n            const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n              densityFactor\n            })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n          } else {\n            baseRowHeight = existingBaseRowHeight;\n          }\n\n          hasRowWithAutoHeight.current = true;\n          rowsHeightLookup.current[row.id].autoHeight = true;\n        } else {\n          // Default back to base rowHeight if getRowHeight returns null or undefined.\n          baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n          rowsHeightLookup.current[row.id].autoHeight = false;\n        }\n      } else {\n        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n      }\n\n      const existingBaseSizes = Object.entries(sizes).reduce((acc, [key, size]) => {\n        if (/^base[A-Z]/.test(key)) {\n          acc[key] = size;\n        }\n\n        return acc;\n      }, {}); // We use an object to make simple to check if a height is already added or not\n\n      const initialHeights = _extends({}, existingBaseSizes, {\n        baseCenter: baseRowHeight\n      });\n\n      if (getRowSpacing) {\n        var _spacing$top, _spacing$bottom;\n\n        const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n        const spacing = getRowSpacing(_extends({}, row, {\n          isFirstVisible: indexRelativeToCurrentPage === 0,\n          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n          indexRelativeToCurrentPage\n        }));\n        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n      }\n\n      const processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n      rowsHeightLookup.current[row.id].sizes = processedSizes;\n      return processedSizes;\n    };\n\n    const positions = [];\n    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n      positions.push(acc);\n      let maximumBaseSize = 0;\n      let otherSizes = 0;\n      const processedSizes = calculateRowProcessedSizes(row);\n      Object.entries(processedSizes).forEach(([size, value]) => {\n        if (/^base[A-Z]/.test(size)) {\n          maximumBaseSize = value > maximumBaseSize ? value : maximumBaseSize;\n        } else {\n          otherSizes += value;\n        }\n      });\n      return acc + maximumBaseSize + otherSizes;\n    }, 0);\n    pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight,\n          positions\n        }\n      });\n    });\n\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows]);\n  const getRowHeight = React.useCallback(rowId => {\n    const height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.baseCenter : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n\n  const getRowInternalSizes = rowId => {\n    var _rowsHeightLookup$cur;\n\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n\n  const setRowHeight = React.useCallback((id, height) => {\n    rowsHeightLookup.current[id].sizes.baseCenter = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const debouncedHydrateRowsMeta = React.useMemo(() => debounce(hydrateRowsMeta), [hydrateRowsMeta]);\n  const storeMeasuredRowHeight = React.useCallback((id, height, position) => {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n\n    const needsHydration = rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes[`base${capitalize(position)}`] = height;\n\n    if (needsHydration) {\n      debouncedHydrateRowsMeta();\n    }\n  }, [debouncedHydrateRowsMeta]);\n  const rowHasAutoHeight = React.useCallback(id => {\n    var _rowsHeightLookup$cur2;\n\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  const getLastMeasuredRowIndex = React.useCallback(() => {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  const setLastMeasuredRowIndex = React.useCallback(index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []);\n  const resetRowHeights = React.useCallback(() => {\n    rowsHeightLookup.current = {};\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(() => {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  const rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight,\n    resetRowHeights\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}